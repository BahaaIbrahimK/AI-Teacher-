# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_bsWt09WjDNgm-XmEWWEAYKtphMMrb6f
"""

from flask import Flask, request, jsonify
import google.generativeai as genai
import json
import time
import re
import os
import logging
from typing import Optional, Dict, List
import urllib.parse
import requests
from bs4 import BeautifulSoup

# Initialize Flask app
app = Flask(__name__)

# Configure Gemini API
GEMINI_API_KEY = "AIzaSyAkAnUzwSeE_Xv_89IRJQy545bqkKuZIL0"  # Consider using environment variables
genai.configure(api_key=GEMINI_API_KEY)

# Initialize the Gemini model
model = genai.GenerativeModel('gemini-2.0-flash')

# Configure APIs
YOUTUBE_API_KEY = "AIzaSyAe9MqHF6Z0oV8e0qj0T-FhTuSj28-AQ44"  # Use environment variables
GOOGLE_SEARCH_API_KEY = "94173181c3f7b45887d266b3d739c13505fa2d5c"  # Use environment variables
GOOGLE_CSE_ID = "102209514661688191236"  # Use environment variables

def extract_json(text):
    """Extracts JSON from a response that might contain extra text."""
    match = re.search(r'\[\s*\{.*\}\s*\]', text, re.DOTALL)
    if match:
        return match.group(0)
    return None

@app.route('/generate_questions', methods=['POST'])
def generate_questions_api():
    """API endpoint to generate assessment questions."""
    try:
        data = request.get_json()
        if not data or 'topic' not in data:
            return jsonify({"error": "Topic is required"}), 400

        topic = data['topic']
        num_questions = 5
        difficulty_levels = ["easy", "medium", "hard"]

        questions = generate_assessment_questions(
            topic=topic,
            difficulty_levels=difficulty_levels,
            num_questions=num_questions
        )

        if not questions:
            return jsonify({"error": "Failed to generate questions"}), 500

        try:
            questions_data = json.loads(questions)
            return jsonify({
                "status": "success",
                "topic": topic,
                "questions": questions_data
            })
        except json.JSONDecodeError:
            return jsonify({"error": "Invalid question format generated"}), 500

    except Exception as e:
        return jsonify({"error": str(e)}), 500

def generate_assessment_questions(topic, difficulty_levels=["easy", "medium", "hard"], num_questions=5):
    """Generates multiple unique multiple-choice questions."""
    prompt = f"""
    Generate {num_questions} unique multiple-choice questions on {topic}.
    - Distribute the questions across difficulty levels: {difficulty_levels}.
    - Each question must focus on a different concept or subtopic within {topic}.
    - Include 4 distinct answer choices (A, B, C, D).
    - Indicate the correct answer explicitly.

    Output ONLY a valid JSON list without explanations or additional text.
    """
    try:
        response = model.generate_content(prompt)
        raw_text = response.text.strip()
        json_text = extract_json(raw_text)
        return json_text if json_text else None
    except Exception as e:
        print(f"Error generating questions: {e}")
        return None

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

class RoadmapGenerator:
    def __init__(self, model_name: str = "gemini-2.0-flash"):
        try:
            self.model = genai.GenerativeModel(model_name)
            self.max_tokens = 2048
            self.temperature = 0.7
            logging.info(f"Initialized RoadmapGenerator with model: {model_name}")
        except Exception as e:
            logging.error(f"Failed to initialize model: {str(e)}")
            raise

    def validate_inputs(self, field: str, difficulty: str, weeks: int, content_type: str) -> bool:
        if not field or not isinstance(field, str) or len(field.strip()) < 3:
            logging.error("Field must be a meaningful string (min 3 chars)")
            return False

        valid_difficulties = ["Beginner", "Intermediate", "Advanced"]
        if difficulty not in valid_difficulties:
            logging.error(f"Difficulty must be one of: {valid_difficulties}")
            return False

        if not isinstance(weeks, int) or weeks < 1 or weeks > 26:
            logging.error("Weeks must be integer between 1-26")
            return False

        valid_content_types = ["Videos", "Text"]
        if content_type not in valid_content_types:
            logging.error(f"Content type must be one of: {valid_content_types}")
            return False

        return True

    def get_youtube_video(self, query: str) -> Optional[str]:
        """Get the most relevant YouTube video for a search query"""
        try:
            url = f"https://www.googleapis.com/youtube/v3/search?part=snippet&maxResults=1&q={urllib.parse.quote(query)}&key={YOUTUBE_API_KEY}&type=video&videoEmbeddable=true"

            response = requests.get(url)
            if response.status_code == 200:
                data = response.json()
                if data.get('items'):
                    video_id = data['items'][0]['id']['videoId']
                    return f"https://www.youtube.com/watch?v={video_id}"
        except Exception as e:
            logging.error(f"Error fetching YouTube video: {str(e)}")
        return None

    def get_article_link(self, title: str, description: str) -> Optional[str]:
        """Get article link using Gemini's knowledge"""
        try:
            prompt = f"""
            Provide ONE direct link to the best online article about: {title} - {description}
            The article should be from a reputable source like Real Python, freeCodeCamp, GeeksforGeeks, etc.
            Return ONLY the URL with no additional text or explanation.
            Example: https://realpython.com/python-lists-tuples/
            """

            response = model.generate_content(prompt)
            url = response.text.strip()

            # Validate it looks like a URL
            if re.match(r'^https?://\S+', url):
                return url
            return None
        except Exception as e:
            logging.error(f"Error getting article link from Gemini: {str(e)}")
            return None

    def extract_structured_content(self, line: str, content_type: str) -> Optional[Dict]:
        try:
            pattern = r'Week\s+(\d+):\s*([^-]+)\s*-?\s*(.*)'

            if re.match(pattern, line):
                week, title, desc = re.search(pattern, line).groups()
                result = {
                    "week": int(week),
                    "title": title.strip(),
                    "description": desc.strip(),
                    "contentType": content_type.lower()
                }

                if content_type == "Videos":
                    # Keep existing YouTube link logic
                    search_query = f"{title} {desc}"
                    video_link = self.get_youtube_video(search_query)
                    result["contentLink"] = video_link if video_link else \
                        f"https://www.youtube.com/results?search_query={urllib.parse.quote_plus(search_query)}"
                else:
                    # Get article link directly from Gemini
                    article_link = self.get_article_link(title, desc)
                    result["contentLink"] = article_link if article_link else \
                        f"https://www.google.com/search?q={urllib.parse.quote_plus(title + ' ' + desc)}"

                return result

            return None
        except Exception as e:
            logging.warning(f"Parse error for line: {line} - {str(e)}")
            return None

    def generate_roadmap(self, field: str, difficulty: str, weeks: int, content_type: str = "Videos") -> Optional[List[Dict]]:
        if not self.validate_inputs(field, difficulty, weeks, content_type):
            return None

        prompt = f"""Generate a {weeks}-week learning roadmap for {field} at {difficulty} level.

        CONTENT TYPE: {content_type}

        FORMAT REQUIREMENTS:
        - One week per line
        - Format: 'Week X: Title - Description'
        - Make titles specific and searchable
        - Focus on popular topics with available content

        CONTENT REQUIREMENTS:
        - For Videos: Focus on tutorial-style content
        - For Text: Focus on well-written articles, documentation, and guides

        EXAMPLE OUTPUT:
        Week 1: Python Basics - Introduction to variables, data types and basic operations
        Week 2: Control Flow in Python - Understanding conditionals and loops
        ... up to Week {weeks}"""

        try:
            response = self.model.generate_content(
                prompt,
                generation_config=genai.types.GenerationConfig(
                    max_output_tokens=self.max_tokens,
                    temperature=0.3,
                    top_p=0.7
                )
            )

            if not response.text:
                logging.error("Empty response from model")
                return None

            roadmap = []
            for line in response.text.split('\n'):
                if line.strip():
                    content = self.extract_structured_content(line.strip(), content_type)
                    if content:
                        roadmap.append(content)

            if len(roadmap) < weeks:
                logging.error(f"Only got {len(roadmap)} weeks instead of {weeks}")
                return None

            return roadmap[:weeks]

        except Exception as e:
            logging.error(f"Generation error: {str(e)}")
            return None

@app.route('/generate_roadmap', methods=['POST'])
def generate_roadmap_api():
    try:
        data = request.get_json()

        if not data:
            return jsonify({"error": "No JSON data provided"}), 400

        try:
            field = str(data['field']).strip()
            difficulty = str(data['difficulty']).strip()
            weeks = int(data['weeks'])
            content_type = str(data.get('content_type', 'Videos')).strip()
        except (KeyError, ValueError) as e:
            return jsonify({
                "error": "Invalid input parameters",
                "details": str(e),
                "required": {
                    "field": "string",
                    "difficulty": "Beginner|Intermediate|Advanced",
                    "weeks": "int (1-26)"
                },
                "optional": {
                    "content_type": "Videos|Text (default: Videos)"
                }
            }), 400

        generator = RoadmapGenerator()
        roadmap = generator.generate_roadmap(field, difficulty, weeks, content_type)

        if not roadmap:
            return jsonify({
                "error": "Failed to generate roadmap",
                "possible_reasons": [
                    "Invalid or too broad topic",
                    "Unsupported difficulty level",
                    "Too many weeks requested",
                    "API service unavailable"
                ]
            }), 400

        # Add quiz questions for each week
        for week in roadmap:
            quiz_prompt = f"""
            Generate 5 multiple-choice questions about: {week['title']} - {week['description']}
            - Each question should have 4 options (A, B, C, D)
            - Include the correct answer
            - Cover different aspects of the topic
            - Output ONLY JSON format
            """

            try:
                quiz_response = model.generate_content(quiz_prompt)
                quiz_text = quiz_response.text.strip()
                quiz_json = extract_json(quiz_text)
                if quiz_json:
                    week['weekQuiz'] = json.loads(quiz_json)
                else:
                    week['weekQuiz'] = []
            except Exception as e:
                week['weekQuiz'] = []

        return jsonify({
            "status": "success",
            "metadata": {
                "field": field,
                "difficulty": difficulty,
                "weeks": len(roadmap),
                "content_type": content_type
            },
            "roadmap": roadmap
        })

    except Exception as e:
        logging.error(f"API error: {str(e)}")
        return jsonify({
            "error": "Internal server error",
            "details": str(e)
        }), 500

@app.route('/test', methods=['GET', 'POST'])
def test():
    return "OK", 200

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))